/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import * as coreHttp from "@azure/core-http";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
/** Class representing a Directory. */
export class Directory {
    /**
     * Initialize a new instance of the class Directory class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Create a directory. By default, the destination is overwritten and if the destination already exists
     * and has a lease the lease is broken. This operation supports conditional HTTP requests.  For more
     * information, see [Specifying Conditional Headers for Blob Service
     * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
     *  To fail if the destination already exists, use a conditional request with If-None-Match: "*".
     * @param options The options parameters.
     */
    create(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec);
    }
    /**
     * Rename a directory. By default, the destination is overwritten and if the destination already exists
     * and has a lease the lease is broken. This operation supports conditional HTTP requests. For more
     * information, see [Specifying Conditional Headers for Blob Service
     * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
     * To fail if the destination already exists, use a conditional request with If-None-Match: "*".
     * @param renameSource The file or directory to be renamed. The value must have the following format:
     *                     "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties will overwrite the
     *                     existing properties; otherwise, the existing properties will be preserved.
     * @param options The options parameters.
     */
    rename(renameSource, options) {
        const operationArguments = {
            renameSource,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, renameOperationSpec);
    }
    /**
     * Deletes the directory
     * @param recursiveDirectoryDelete If "true", all paths beneath the directory will be deleted. If
     *                                 "false" and the directory is non-empty, an error occurs.
     * @param options The options parameters.
     */
    delete(recursiveDirectoryDelete, options) {
        const operationArguments = {
            recursiveDirectoryDelete,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec);
    }
    /**
     * Set the owner, group, permissions, or access control list for a directory.
     * @param options The options parameters.
     */
    setAccessControl(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setAccessControlOperationSpec);
    }
    /**
     * Get the owner, group, permissions, or access control list for a directory.
     * @param options The options parameters.
     */
    getAccessControl(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getAccessControlOperationSpec);
    }
}
// Operation Specifications
const xmlSerializer = new coreHttp.Serializer(Mappers, /* isXml */ true);
const createOperationSpec = {
    path: "/{filesystem}/{path}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: Mappers.DirectoryCreateHeaders
        },
        default: {
            bodyMapper: Mappers.DataLakeStorageError,
            headersMapper: Mappers.DirectoryCreateExceptionHeaders
        }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.resource],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.directoryProperties,
        Parameters.posixPermissions,
        Parameters.posixUmask,
        Parameters.cacheControl,
        Parameters.contentType1,
        Parameters.contentEncoding,
        Parameters.contentLanguage,
        Parameters.contentDisposition,
        Parameters.ifMatch,
        Parameters.ifNoneMatch
    ],
    isXML: true,
    serializer: xmlSerializer
};
const renameOperationSpec = {
    path: "/{filesystem}/{path}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: Mappers.DirectoryRenameHeaders
        },
        default: {
            bodyMapper: Mappers.DataLakeStorageError,
            headersMapper: Mappers.DirectoryRenameExceptionHeaders
        }
    },
    queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.marker1,
        Parameters.pathRenameMode
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.sourceLeaseId,
        Parameters.directoryProperties,
        Parameters.posixPermissions,
        Parameters.posixUmask,
        Parameters.cacheControl,
        Parameters.contentType1,
        Parameters.contentEncoding,
        Parameters.contentLanguage,
        Parameters.contentDisposition,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.renameSource,
        Parameters.sourceIfModifiedSince,
        Parameters.sourceIfUnmodifiedSince,
        Parameters.sourceIfMatch,
        Parameters.sourceIfNoneMatch
    ],
    isXML: true,
    serializer: xmlSerializer
};
const deleteOperationSpec = {
    path: "/{filesystem}/{path}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: Mappers.DirectoryDeleteHeaders
        },
        default: {
            bodyMapper: Mappers.DataLakeStorageError,
            headersMapper: Mappers.DirectoryDeleteExceptionHeaders
        }
    },
    queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.marker1,
        Parameters.recursiveDirectoryDelete
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch
    ],
    isXML: true,
    serializer: xmlSerializer
};
const setAccessControlOperationSpec = {
    path: "/{filesystem}/{path}",
    httpMethod: "PATCH",
    responses: {
        200: {
            headersMapper: Mappers.DirectorySetAccessControlHeaders
        },
        default: {
            bodyMapper: Mappers.DataLakeStorageError,
            headersMapper: Mappers.DirectorySetAccessControlExceptionHeaders
        }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.action5],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.posixPermissions,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.owner,
        Parameters.group,
        Parameters.posixAcl
    ],
    isXML: true,
    serializer: xmlSerializer
};
const getAccessControlOperationSpec = {
    path: "/{filesystem}/{path}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: Mappers.DirectoryGetAccessControlHeaders
        },
        default: {
            bodyMapper: Mappers.DataLakeStorageError,
            headersMapper: Mappers.DirectoryGetAccessControlExceptionHeaders
        }
    },
    queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.action6,
        Parameters.upn
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.requestId,
        Parameters.accept1,
        Parameters.leaseId,
        Parameters.ifModifiedSince,
        Parameters.ifUnmodifiedSince,
        Parameters.ifMatch,
        Parameters.ifNoneMatch
    ],
    isXML: true,
    serializer: xmlSerializer
};
//# sourceMappingURL=directory.js.map